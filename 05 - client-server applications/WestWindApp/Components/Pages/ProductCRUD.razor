@page "/productcrud/{productid:int?}"﻿
@* ^ putting a dynamic parameter in the URL allows us to,
    in this case, land on a form page with that Product's data prepopulated (update page)
*@
<PageTitle>Product CRUD</PageTitle>
@rendermode InteractiveServer

<!-- Additional namespaces-->
@using WestWindSystem.BLL;
@using WestWindSystem.Entities;

<h1>Product CRUD</h1>
<cite> ... demonstrating CRUD using EditForm</cite>

<br />
<br />

@if (feedBackMsg.Length > 0)
{
    <div class="alert alert-info">
        <p>@feedBackMsg</p>
    </div>
}

@if (errorMsgs.Count > 0)
{
    <div class="alert alert-danger">
        <p>Please fix the following issues:</p>
        <ul>
            @foreach (var error in errorMsgs)
            {
                <li>@error</li>
            }
        </ul>
    </div>
}

<br />
<br />
<!-- EditForm

You've used EditForms before! Now we're using them again, to *write* objects.

-->

<EditForm EditContext="editContext">
    <DataAnnotationsValidator/>
    <ValidationSummary/>


    <div class="row">
        <div class="offset-1 col-md-4">
            <label for="productid" class="form-label">Product ID</label>

            <!--
                When using an EditForm, we use Blazor's component-based input fields.

                When creating an instance, *do not* let the user decide the primary key!
                 -> i.e., do not let the user decide/input whichever property is the PK.
                    Here, that's the ProductID.

                A simple way of doing that on the front-end is giving the input a readonly attribute,
                just to make it conventionally inaccessible by the user.

                This is not enough in itself though, because a user could just remove the readonly
                tag via developer console in their browser. It's just a visual/interactive barrier.
            -->
            <InputNumber id="productid" class="form-control"
                        @bind-Value="currentProduct.ProductID"
                        style="width: 75px;" readonly />
            <br/>
            <label for="productname" class="form-label">Name</label>
            <InputText id="productname" class="form-control"
                        @bind-Value="currentProduct.ProductName" />
            <ValidationMessage For="@(() => currentProduct.ProductName)" />

            <!-- Foreign Keys-->
            <!--
                The Product has a Category foreignkey.
                We loop from available choices in db instances, so the only possible values
                are valid options from the actual data backend.

                You've already done this too - looping through a query result to generate
                <option>s inside a <select>.

            -->
            <br />
            <label for="categoryid" class="form-label">Category</label>
            <InputSelect id="categoryid" @bind-Value="currentProduct.CategoryID" class="form-control">
                <option value="0">... select category ...</option>
                @foreach(var item in categoryList)
                {
                    <option value="@item.CategoryID">@item.CategoryName</option>
                }
            </InputSelect>
            <ValidationMessage For="@(() => currentProduct.CategoryID)" />

            <br />

            <label for="supplierid" class="form-label">Supplier</label>
            <InputSelect id="supplierid" @bind-Value="currentProduct.SupplierID" class="form-control">
                <option value="0">... select supplier ...</option>
                @foreach (var item in supplierList)
                {
                    <option value="@item.SupplierID">@item.CompanyName</option>
                }
            </InputSelect>
            <ValidationMessage For="@(() => currentProduct.SupplierID)" />


        </div>
   
        <!-- Yep... we have to include inputs for every user-settable property on the class. 
        -->
        <div class="offset-1 col-md-4">
            <label for="qtyperunit" class="form-label">Qty / Unit</label>
            <InputText id="qtyperunit" class="form-control"
                       @bind-Value="currentProduct.QuantityPerUnit" />
            <ValidationMessage For="@(() => currentProduct.QuantityPerUnit)" />
            <br/>
            <label for="minqty" class="form-label">Min Order Qty</label>
            <InputNumber id="minqty" class="form-control"
                       @bind-Value="currentProduct.MinimumOrderQuantity" />
            <ValidationMessage For="@(() => currentProduct.MinimumOrderQuantity)" />
            <br />
            <label for="unitprice" class="form-label">Unit Price</label>
            <InputNumber id="unitprice" class="form-control"
                         @bind-Value="FormatUnitPrice" />
            <ValidationMessage For="@(() => currentProduct.UnitPrice)" />
            <br />
            <label for="unitsonorder" class="form-label">Units on Order</label>
            <InputNumber id="unitsonorder" class="form-control"
                         @bind-Value="currentProduct.UnitsOnOrder" />
            <ValidationMessage For="@(() => currentProduct.UnitsOnOrder)" />
        </div>
    </div>

    <br />

    <div class="row">
        <div class="col-md-12 text-center">
            <button type="button" class="btn btn-outline-primary rounded-pill"
                    @onclick="OnCreate" style="width:160px;">
                Create    
            </button>
            &nbsp;&nbsp;
            <button type="button" class="btn btn-outline-primary rounded-pill"
                    @onclick="OnUpdate" style="width:160px;">
                Update
            </button>
            &nbsp;&nbsp;
            <button type="button" class="btn btn-outline-primary rounded-pill"
                    @onclick="OnDiscontinued" style="width:160px;">
                Discontinue
            </button>
            &nbsp;&nbsp;
            <button type="button" class="btn btn-outline-secondary rounded-pill"
                    @onclick="OnClear" style="width:160px;">
                Clear
            </button>
            &nbsp;&nbsp;
            <button type="button" class="btn btn-outline-primary rounded-pill"
                    @onclick="OnSearch" style="width:160px;">
                Search a product
            </button>
        </div>
    </div>
</EditForm>

@code {
    private string feedBackMsg = "";
    private List<string> errorMsgs = new();



    //  In an implementation where we're not just binding to a model, editContext holds
    //  the input data we're generating for the new instance we want to create.
    private EditContext editContext;

    //  Here's our error message container.
    private ValidationMessageStore validationMessageStore;

    // Here's a product instance that starts empty.
    private Product currentProduct = new();

    // Because we're allowing foreignkey properties to be set, we inject the query service
    // for that foreignkey object.
    [Inject]
    public CategoryServices _categoryServices { get; set; }
    private List<Category> categoryList = new();

    [Inject]
    public SupplierServices _supplierServices { get; set; }
    private List<Supplier> supplierList = new();

    [Inject]
    public ProductServices _productServices { get; set; }

    [Inject]
    public IJSRuntime jsRuntime { get; set; }

    [Inject]
    private NavigationManager _navManager { get; set; }

    // I'll control access to /productcrud/{int:productID} by reading a variable from the URL
    // That I'll set here as a parameter.
    // A Parameter becomes a property of the component (i.e. this page, e.g. ProductCRUD.productid)
    [Parameter]
    public int? productid { get; set; }

    private decimal FormatUnitPrice
    {
        get { return Math.Round(currentProduct.UnitPrice, 2); } // return a decimal rounded to 2 places
        set { currentProduct.UnitPrice = value;  }
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();

        // we're going to use productid (from our URL, stored the int parameter productit)
        // to try to look up an existing instance from the database.
        // If we got e.g. /productcrud/17, that implies updating an existing instance (not creating)
        // so we prepopulate the form with that instance's data! (How else were you planning on *editing* it?)
        // It makes sense to do this when the page initially loads; that's why the user's here in the first place.
        if (productid.HasValue)
            currentProduct = _productServices.Product_GetByID(productid.Value);

        // create & associate instances
        editContext = new EditContext(currentProduct);
        validationMessageStore = new ValidationMessageStore(editContext);

        // fill the foreignkey input field collections via query methods from service layer (BLL)
        categoryList = _categoryServices.Category_GetAll();
        supplierList = _supplierServices.Supplier_GetAll();

    }

    private void OnCreate()
    {
        // You've seen this all before!
        feedBackMsg = "";
        errorMsgs.Clear();
        validationMessageStore.Clear();

        try
        {
            // try-catch to collect input errors (and trigger error message display),
            // and only allow the object to be written to db if there are no errors.
            if (editContext.Validate())
            {
                if (currentProduct.CategoryID == 0)  // foreignkey PK values can't be zero
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.CategoryID)),
                                                "You must select a category");
                }
                if (currentProduct.SupplierID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.SupplierID)),
                                            "You must select a supplier");
                }
                if (currentProduct.UnitPrice < 0.0m)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.UnitPrice)),
                                           "Unit price must be zero or greater.");
                }

                // trigger error messages if we had any issues
                if (editContext.GetValidationMessages().Any())
                {
                    editContext.NotifyValidationStateChanged();
                }
                else
                {

                    // writing the new instance via creation method we wrote in the service layer:
                    int newProductId = _productServices.Product_Add(currentProduct);

                    feedBackMsg = $"Product {currentProduct.ProductName} (ID: {newProductId}) has been added to database.";
                }

            }
        }
        catch (Exception ex)
        {
            feedBackMsg = $"System Error: {ex.Message}";
        }

    }

    // A better design pattern, if create/update validation were identical, would be having
    // a shared method called in OnCreate / OnUpdate that does that work first.
    // Then, if you had any validation changes you'd want to make, you'd only have to implement them once!
    // In this example, we're writing everything out in full.
    private void OnUpdate()
    {
        //clear old messages
        feedBackMsg = "";
        errorMsgs.Clear();
        validationMessageStore.Clear();

        try
        {
            if (editContext.Validate())
            {
                if (currentProduct.CategoryID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.CategoryID)),
                                                "You must select a category");
                }
                if (currentProduct.SupplierID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.SupplierID)),
                                            "You must select a supplier");
                }
                if (currentProduct.UnitPrice < 0.0m)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.UnitPrice)),
                                           "Unit price must be zero or greater.");
                }
                if (editContext.GetValidationMessages().Any())
                {
                    //notify the editcontext that there has been a change to the message store
                    editContext.NotifyValidationStateChanged();
                }
                else
                {
                    int rowsaffected = _productServices.Product_Update(currentProduct);

                    //Question: DID you ACTUALLY change any records?
                    //situation: an update was attempted but no records on the database were
                    //              actually change AND the action did NOT abort
                    //in this case rowsafftected = 0

                    if (rowsaffected == 0)
                    {
                        feedBackMsg = $"Product {currentProduct.ProductName} (ID: {currentProduct.ProductID}) change failed.";
                    }
                    else
                    {
                        feedBackMsg = $"Product {currentProduct.ProductName} (ID: {currentProduct.ProductID}) change were saved.";
                    }
                }
            }
        }
        catch (Exception ex)
        {
            feedBackMsg = $"System Error: {ex.Message}";
        }
    }

    private void OnDiscontinued()
    {
        //clear old messages
        feedBackMsg = "";
        errorMsgs.Clear();
        validationMessageStore.Clear();

        try
        {
            //the custom validation is dependent on how you manage your
            //  product service method
            //a) if you are NOT going to use the incoming data to update
            //   your product before setting the Discontinued field to true
            //   then you do NOT need to do this custom validation
            //OR
            //b) you are going to allow update and discontinue to happen on
            //      the discontinue THEN you DO need to do this custom validation
            if (editContext.Validate())
            {
                if (currentProduct.CategoryID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.CategoryID)),
                                                "You must select a category");
                }
                if (currentProduct.SupplierID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.SupplierID)),
                                            "You must select a supplier");
                }
                if (currentProduct.UnitPrice < 0.0m)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.UnitPrice)),
                                           "Unit price must be zero or greater.");
                }
                if (editContext.GetValidationMessages().Any())
                {
                    //notify the editcontext that there has been a change to the message store
                    editContext.NotifyValidationStateChanged();
                }
                else
                {
                    // if you wanted to do a physical delete, i.e. wipe it from the DB,
                    // you may as well skip all the validation above, and call
                    // _productServices.Product_PhysicalDelete(currentProduct) instead
                    int rowsaffected = _productServices.Product_LogicalDelete(currentProduct);

                    //Question: DID you ACTUALLY change any records?


                    if (rowsaffected == 0)
                    {
                        feedBackMsg = $"Product {currentProduct.ProductName} (ID: {currentProduct.ProductID}) discontinue failed.";
                    }
                    else
                    {
                        feedBackMsg = $"Product {currentProduct.ProductName} (ID: {currentProduct.ProductID}) has been disconntinued.";
                    }
                }
            }
        }
        catch (Exception ex)
        {
            feedBackMsg = $"System Error: {ex.Message}";
        }
    }

    // Change this method to return an asynchronous Task to allow JS-interactive behaviour.
    // This lets us issue a JS popup and alter our page data in the background (here, clearing the form).
    private async Task OnClear()
    {
        // generic behaviour for clearing out the form
        feedBackMsg = "";
        errorMsgs.Clear();

        // set up and execute a popup dialog using JavaScript behaviour
        object[] messageString = new object[]
            {"Clearing the page will lose all unsaved data. Do you want to continue?"};

        // Trigger a boolean popup (confirm/cancel) and clear only if the user confirms.
        if (await(jsRuntime.InvokeAsync<bool>("confirm",messageString)))

            // Move all our original clear behaviour here!
            validationMessageStore.Clear();

        currentProduct = new Product();
        // currentProduct.ProductName = "unknown";
        // currentProduct.QuantityPerUnit = "unknown";

        // We *must* create a new blank EditContext instance for the next addition
        editContext = new EditContext(currentProduct);   
    }

    private async Task OnSearch()
    {
        // clear old feedback 
        feedBackMsg = "";
        errorMsgs.Clear();

        // Trigger popup to confirm navigating to search page
        // NavigationManager, the component we can call for routing to another page,
        // can take us straight there with a method call to the URL!
        object[] messageString = new object[]
            {"Leaving the page will lose all unsaved data. Do you want to continue?"};
        if (await (jsRuntime.InvokeAsync<bool>("confirm",messageString)))
        {
            _navManager.NavigateTo("/categoryproducts");
        }
    }
}